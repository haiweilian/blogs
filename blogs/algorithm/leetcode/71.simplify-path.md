---
title: 71.简化路径
date: 2021-03-07
tags:
  - LeetCode
categories:
  - 算法
---

## 题目描述

以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。[Linux/Unix 中的绝对路径 vs 相对路径](https://blog.csdn.net/u011327334/article/details/50355600)

请注意，返回的规范路径必须始终以斜杠 `/` 开头，并且两个目录名之间必须只有一个斜杠 `/`。最后一个目录名（如果存在）不能以 `/` 结尾。此外，规范路径必须是表示绝对路径的最短字符串。

**示例 1：**

```md
输入："/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。
```

**示例 2：**

```md
输入："/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。
```

**示例 3：**

```md
输入："/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
```

**示例 4：**

```md
输入："/a/../../b/../c//.//"
输出："/c"
```

## 解法一之栈

**使用栈记录每一步的操作，根据操作分别入栈和出栈，最后再拆分成字符串**

1. 首先应该做的是把字符串以 `/` 拆分成数组依次遍历，其中的元素可能是以下几种情况。
2. 如果是 `".."` 是返回上一层，那么出栈一个。
3. 如果是 `""` 或者 `"."` 不影响层级，不变。
4. 如果是其他的正常字符，则把当前字符入栈。
5. 最后把数组以 `"/"` 拆分成字符串并在前面加上 `"/"` 表示绝对路径。

**代码实现**

```js
/**
 * @param {string} path
 * @return {string}
 */
var simplifyPath = function (path) {
  let stack = [];
  let paths = path.split("/");

  for (let i = 0; i < paths.length; i++) {
    let p = paths[i];
    if (p === "..") {
      // 如果是 ".." 回到到上一层，则出栈一层
      stack.pop();
    } else if (p != "" && p != ".") {
      // "" 和 "." 不管，其他入栈一层
      stack.push(p);
    }
  }

  // 最后拆分成字符串，并以 "/" 开头
  return `/${stack.join("/")}`;
};
// ===================================================================
// ========================== @test ==================================
// ===================================================================
console.log(simplifyPath("/a/./b/../../c/")); // "/c"
console.log(simplifyPath("/a//b////c/d//././/..")); // "/a/b/c"
console.log(simplifyPath("../../")); // "/"
```
